
-- CORREÇÃO DE ERRO: Incompatibilidade de Tipos (UUID vs BIGINT)
-- O erro ocorreu porque a tabela "estoque_restaurantes" já existia com a coluna "produto_id" como UUID,
-- mas a tabela "Produtos" usa ID numérico (BIGINT).
-- A solução é recriar a tabela "estoque_restaurantes" com o tipo correto.

-- 1. Remover tabela incorreta
DROP TABLE IF EXISTS public.estoque_restaurantes CASCADE;

-- 2. Recriar tabela com tipos corretos
CREATE TABLE public.estoque_restaurantes (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    produto_id BIGINT UNIQUE NOT NULL, -- AGORA CORRETO: BIGINT para bater com Produtos.id
    restaurante_id UUID NOT NULL,
    quantidade_atual TEXT DEFAULT '0',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 3. Trigger: Sincronizar Inserção (Produtos -> Estoque)
CREATE OR REPLACE FUNCTION public.sync_product_to_stock_insert()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.estoque_restaurantes (produto_id, restaurante_id, quantidade_atual)
    VALUES (NEW.id, NEW.restaurante_id, COALESCE(NEW.estoque::text, '0'))
    ON CONFLICT (produto_id) DO UPDATE
    SET quantidade_atual = EXCLUDED.quantidade_atual;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_product_insert ON public."Produtos";
CREATE TRIGGER trg_sync_product_insert
AFTER INSERT ON public."Produtos"
FOR EACH ROW
EXECUTE FUNCTION public.sync_product_to_stock_insert();

-- 4. Trigger: Sincronizar Update de Estoque (Produtos -> Estoque)
CREATE OR REPLACE FUNCTION public.sync_product_to_stock_update()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.estoque IS DISTINCT FROM NEW.estoque THEN
        UPDATE public.estoque_restaurantes
        SET quantidade_atual = NEW.estoque::text
        WHERE produto_id = NEW.id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_product_update ON public."Produtos";
CREATE TRIGGER trg_sync_product_update
AFTER UPDATE ON public."Produtos"
FOR EACH ROW
EXECUTE FUNCTION public.sync_product_to_stock_update();

-- 5. Trigger: Sincronizar Update Reverso (Estoque -> Produtos)
CREATE OR REPLACE FUNCTION public.sync_stock_to_product_update()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE public."Produtos"
    SET estoque = CAST(NEW.quantidade_atual AS INTEGER)
    WHERE id = NEW.produto_id
      AND estoque IS DISTINCT FROM CAST(NEW.quantidade_atual AS INTEGER);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_stock_update ON public.estoque_restaurantes;
CREATE TRIGGER trg_sync_stock_update
AFTER UPDATE ON public.estoque_restaurantes
FOR EACH ROW
EXECUTE FUNCTION public.sync_stock_to_product_update();

-- 6. Trigger: Baixa de Estoque por Pedido (Atualizada)
CREATE OR REPLACE FUNCTION public.baixar_estoque_pedido_v3()
RETURNS TRIGGER AS $$
DECLARE
    item_nome TEXT;
    item_lista TEXT[];
BEGIN
    IF NEW.itens IS NULL OR NEW.itens = '' THEN
        RETURN NEW;
    END IF;

    item_lista := string_to_array(NEW.itens, ',');

    FOREACH item_nome IN ARRAY item_lista LOOP
        -- Atualiza estoque_restaurantes
        UPDATE public.estoque_restaurantes er
        SET quantidade_atual = (CAST(er.quantidade_atual AS INTEGER) - 1)::text
        FROM public."Produtos" p
        WHERE p.id = er.produto_id
          AND TRIM(p.nome) = TRIM(item_nome)
          AND p.restaurante_id = NEW.restaurante_id
          AND CAST(er.quantidade_atual AS INTEGER) > 0;
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 7. Preencher tabela com dados existentes
INSERT INTO public.estoque_restaurantes (produto_id, restaurante_id, quantidade_atual)
SELECT id, restaurante_id, estoque::text
FROM public."Produtos"
ON CONFLICT (produto_id) DO NOTHING;
