
-- 1. Ensure Table Exists
CREATE TABLE IF NOT EXISTS public.estoque_restaurantes (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    produto_id BIGINT UNIQUE NOT NULL, -- Changed to BIGINT to match Produtos.id type
    restaurante_id UUID NOT NULL,
    quantidade_atual TEXT DEFAULT '0', -- Keeping TEXT as per user screenshot/request, though INTEGER is better
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- 2. Sync Trigger: Produtos (INSERT) -> estoque_restaurantes (INSERT)
CREATE OR REPLACE FUNCTION public.sync_product_to_stock_insert()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.estoque_restaurantes (produto_id, restaurante_id, quantidade_atual)
    VALUES (NEW.id, NEW.restaurante_id, COALESCE(NEW.estoque::text, '0'))
    ON CONFLICT (produto_id) DO UPDATE
    SET quantidade_atual = EXCLUDED.quantidade_atual; -- Handle re-insertion or conflict
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_product_insert ON public."Produtos";
CREATE TRIGGER trg_sync_product_insert
AFTER INSERT ON public."Produtos"
FOR EACH ROW
EXECUTE FUNCTION public.sync_product_to_stock_insert();

-- 3. Sync Trigger: Produtos (UPDATE estoque) -> estoque_restaurantes (UPDATE)
-- This handles when stock is changed via the UI (SettingsModal) which updates Produtos
CREATE OR REPLACE FUNCTION public.sync_product_to_stock_update()
RETURNS TRIGGER AS $$
BEGIN
    IF OLD.estoque IS DISTINCT FROM NEW.estoque THEN
        UPDATE public.estoque_restaurantes
        SET quantidade_atual = NEW.estoque::text
        WHERE produto_id = NEW.id;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_product_update ON public."Produtos";
CREATE TRIGGER trg_sync_product_update
AFTER UPDATE ON public."Produtos"
FOR EACH ROW
EXECUTE FUNCTION public.sync_product_to_stock_update();


-- 4. Sync Trigger: estoque_restaurantes (UPDATE) -> Produtos (UPDATE)
-- This allows updates directly to inventory table to reflect in the app
CREATE OR REPLACE FUNCTION public.sync_stock_to_product_update()
RETURNS TRIGGER AS $$
BEGIN
    -- Avoid infinite loop by checking if value is actually different
    UPDATE public."Produtos"
    SET estoque = CAST(NEW.quantidade_atual AS INTEGER)
    WHERE id = NEW.produto_id
      AND estoque IS DISTINCT FROM CAST(NEW.quantidade_atual AS INTEGER);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS trg_sync_stock_update ON public.estoque_restaurantes;
CREATE TRIGGER trg_sync_stock_update
AFTER UPDATE ON public.estoque_restaurantes
FOR EACH ROW
EXECUTE FUNCTION public.sync_stock_to_product_update();


-- 5. Updated Order Deduction Function to target estoque_restaurantes directly
-- This ensures "downward" flow: Order -> estoque_restaurantes -> Produtos
CREATE OR REPLACE FUNCTION public.baixar_estoque_pedido_v3()
RETURNS TRIGGER AS $$
DECLARE
    item_nome TEXT;
    item_lista TEXT[];
BEGIN
    IF NEW.itens IS NULL OR NEW.itens = '' THEN
        RETURN NEW;
    END IF;

    item_lista := string_to_array(NEW.itens, ',');

    FOREACH item_nome IN ARRAY item_lista LOOP
        -- Update estoque_restaurantes directly
        -- We find the product ID by name first to link correct inventory record
        UPDATE public.estoque_restaurantes er
        SET quantidade_atual = (CAST(er.quantidade_atual AS INTEGER) - 1)::text
        FROM public."Produtos" p
        WHERE p.id = er.produto_id
          AND TRIM(p.nome) = TRIM(item_nome)
          AND p.restaurante_id = NEW.restaurante_id
          AND CAST(er.quantidade_atual AS INTEGER) > 0;
          
        -- Note: The trigger trg_sync_stock_update on estoque_restaurantes will automatically
        -- update the Produtos table, keeping them in sync.
    END LOOP;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


-- 6. Backfill existing products into estoque_restaurantes (Run once)
INSERT INTO public.estoque_restaurantes (produto_id, restaurante_id, quantidade_atual)
SELECT id, restaurante_id, estoque::text
FROM public."Produtos"
ON CONFLICT (produto_id) DO NOTHING;
